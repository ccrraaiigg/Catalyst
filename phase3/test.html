<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>üöÄ Phase 3 JIT Compilation Test Interface</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .run-multiple {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }
        
        .toggle {
            background: linear-gradient(45deg, #f093fb, #f5576c);
        }
        
        label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #ffd700;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .output {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .output .result {
            color: #4ade80;
            font-weight: bold;
        }
        
        .output .error {
            color: #f87171;
            font-weight: bold;
        }
        
        .info-box {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            border-left: 4px solid #ffd700;
        }
        
        .info-box h3 {
            margin-top: 0;
            color: #ffd700;
        }
        
        .info-box ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .info-box li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
  <script type="module" src="./catalyst.js"></script>

    <div class="container">
        <h1>üöÄ Phase 3 JIT Compilation Test Interface</h1>
        <p class="subtitle">SqueakWASM Virtual Machine with Runtime Bytecode Compilation</p>
        
        <div class="info-box">
            <h3>üéØ Test Features</h3>
            <ul>
                <li><strong>Runtime bytecode translation to WebAssembly</strong></li>
                <li><strong>Hot method detection and automatic compilation</strong></li>
                <li><strong>Performance monitoring and statistics</strong></li>
                <li><strong>Debug mode with detailed compilation logs</strong></li>
            </ul>
            
            <h3>üöÄ Getting Started</h3>
            <ul>
                <li>Click "Run (3 workload) with JIT" to execute the basic example</li>
                <li>Use "Trigger JIT Compilation" to reach the JIT threshold of 1000 invocations (first click) and see optimized execution (subsequent clicks)</li>
                <li>Toggle JIT compilation and debug modes to see different behaviors</li>
                <li>View statistics to monitor performance improvements</li>
            </ul>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="execTime">0.00</div>
                <div class="stat-label">Execution Time (Œºs)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="jitCount">0</div>
                <div class="stat-label">JIT Compilations</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="optimizedMethods">0</div>
                <div class="stat-label">Optimized Methods</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="cacheHits">0</div>
                <div class="stat-label">Cached Methods</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="jitStatus">ENABLED</div>
                <div class="stat-label">JIT Status</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="llmSuccessRate">0%</div>
                <div class="stat-label">LLM Success Rate</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="llmAttempts">0</div>
                <div class="stat-label">LLM Attempts</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="wasmValidationRate">0%</div>
                <div class="stat-label">WASM Validation Rate</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>üéÆ Execution Controls</h3>
                <button id="runExample">Run (3 workload) with JIT</button>
                <button id="runMultiple" class="run-multiple">Trigger JIT Compilation</button>
                <button id="runIntensive" class="run-intensive">üî• Run Intensive Computation</button>
            </div>
            
            <div class="control-group">
                <h3>‚öôÔ∏è VM Configuration</h3>
                <label>
                    <input type="checkbox" id="jitToggle" checked>
                    Enable JIT Compilation
                </label>
                <label>
                    <input type="checkbox" id="debugToggle" checked>
                    Debug Mode
                </label>
                <label>
                    <input type="checkbox" id="llmToggle">
                    ‚òÅÔ∏è LLM Optimization (Auto-enabled if keys file exists)
                </label>
                <button id="clearCache" class="toggle">Clear Method Cache</button>
                <button id="resetStats" class="toggle">Reset Statistics</button>
                <button id="testFunctionTable" class="toggle">Test Function Table</button>
                <button id="detectTimer" class="toggle">Detect Timer Resolution</button>
                <button id="testWabt" class="toggle">Test wabt.js Loading</button>
                <button id="testWasmDump" class="toggle">üîç Test Enhanced WASM Dump</button>
            </div>
        </div>

        <div class="output" id="output">
            <!-- Initialization messages will be added dynamically -->
        </div>

        <button onclick="toggleLLMOptimization()">Toggle LLM Optimization</button>
        <button onclick="testOptimizationCorrectness()">Test Optimization Correctness</button>
    </div>

    <script type="module">
        let vm = null;
        let jitEnabled = true;
        let debugMode = true;
        let llmEnabled = true;
        
        const stats = {
            executionTime: 0,
            jitCompilations: 0,
            cachedMethods: 0,
            jitEnabled: true
        };

        function initVM() {
            if (!vm) {
                return import('./catalyst.js')
                    .then(({ SqueakVM }) => {
                    vm = new SqueakVM();
                        return vm.initialize();
                    })
                    .then(() => {
                    vm.onResult = (result) => {
                        addOutput(`<strong>üì¢ Result received:</strong> ${result}`, 'result');
                    };
                    addOutput('<strong>‚úÖ VM initialized successfully!</strong>');
                    
                    // Check if LLM optimization was auto-enabled with real API key
                    if (vm.llmConfig.apiKey && vm.llmConfig.apiKey !== 'mock-key') {
                        addOutput('<strong>üîë API keys loaded - Real LLM optimization available!</strong>');
                        document.getElementById('llmToggle').checked = true;
                        // Trigger the change event to actually enable LLM optimization
                        document.getElementById('llmToggle').dispatchEvent(new Event('change'));
                    } else {
                        addOutput('<strong>‚ö†Ô∏è No API keys found - LLM will use mock mode when enabled</strong>');
                        addOutput('<strong>üí° Create a "keys" file with: openai=sk-proj-... or anthropic=sk-ant-api03-...</strong>');
                    }
                    })
                    .catch(error => {
                    addOutput(`<strong>‚ùå VM initialization failed:</strong> ${error.message}`, 'error');
                    throw error;
                    });
            }
            // If already initialized, return a resolved promise
            return Promise.resolve();
        }

        function addOutput(text, className = '') {
            const output = document.getElementById('output');
            const line = document.createElement('div');
            if (className) line.className = className;
            line.innerHTML = text;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function updateStats(newStats) {
            document.getElementById('execTime').textContent = newStats.executionTime.toFixed(2);
            document.getElementById('jitCount').textContent = newStats.jitCompilations;
            document.getElementById('optimizedMethods').textContent = newStats.optimizedMethods || 0;
            document.getElementById('cacheHits').textContent = newStats.cachedMethods;
            document.getElementById('jitStatus').textContent = newStats.jitEnabled ? 'ENABLED' : 'DISABLED';
            document.getElementById('llmSuccessRate').textContent = (newStats.llmSuccessRate || 0) + '%';
            document.getElementById('llmAttempts').textContent = newStats.llmAttempts || 0;
            document.getElementById('wasmValidationRate').textContent = (newStats.wasmValidationSuccessRate || 0) + '%';
            
            Object.assign(stats, newStats);
        }

        // Event Listeners
        document.getElementById('runExample').addEventListener('click', () => {
            initVM()
                .then(() => {
                addOutput('<strong>üî• Brief warmup...</strong>');
                vm.setJITEnabled(jitEnabled);
                vm.setDebugMode(debugMode);
                // Single warmup run to eliminate cold start
                return vm.run().then(() => {
                    addOutput('<strong>üöÄ Running 3 workload with JIT compilation...</strong>');
                    const startTime = performance.now();
                    return vm.run().then(result => {
                        const endTime = performance.now();
                        const success = result.success;
                        const vmStats = vm.getJITStatistics();
                        addOutput(`
                            <strong>üìä Execution Result:</strong> ${success ? '‚úÖ PASSED' : '‚ùå FAILED'}<br>
                            ‚Ä¢ Result: ${result.results ? result.results.join(', ') : 'No results'}<br>
                            ‚Ä¢ Execution Time: ${((endTime - startTime) * 1000).toFixed(1)}Œºs<br>
                            ‚Ä¢ JIT Compilations: ${result.jitCompilations || 0}<br>
                            ‚Ä¢ JIT Status: ${jitEnabled ? 'Enabled' : 'Disabled'}
                        `, success ? 'result' : 'error');
                        updateStats({
                            executionTime: (endTime - startTime) * 1000, // Convert to microseconds
                            jitCompilations: result.jitCompilations || 0,
                            optimizedMethods: vmStats.optimizedMethods || 0,
                            cachedMethods: vmStats.cachedMethods || 0,
                            jitEnabled: jitEnabled,
                            llmSuccessRate: vmStats.llmSuccessRate || 0,
                            llmAttempts: vmStats.llmAttempts || 0,
                            wasmValidationSuccessRate: vmStats.wasmValidationSuccessRate || 0
                        });
                    });
                });
                })
                .catch(error => {
                addOutput(`<strong>‚ùå Error:</strong> ${error.message}`, 'error');
                });
        });

        document.getElementById('runMultiple').addEventListener('click', async () => {
            try {
                await initVM();
                
                vm.setJITEnabled(jitEnabled);
                vm.setDebugMode(debugMode);
                
                // Check if methods are already compiled
                const initialStats = vm.getJITStatistics();
                const alreadyCompiled = initialStats.jitCompilations > 0 || initialStats.cachedMethods > 0;
                
                if (alreadyCompiled) {
                    // Methods already compiled - run optimized demo
                    addOutput('<strong>‚ö° Methods already JIT-compiled! Running optimized version...</strong>', 'result');
                    addOutput('<strong>üíæ Using cached compiled methods from previous run</strong>');
                    
                    // Warmup phase to eliminate cold start effects
                    addOutput('<strong>üî• Warming up (eliminating cold start effects)...</strong>');
                    for (let w = 0; w < 10; w++) {
                        await vm.run();
                    }
                    addOutput('<strong>‚úÖ Warmup complete, starting measurements...</strong>');
                    
                    const runs = 1000; // Batch of 1000 runs for reliable averages
                    const results = [];
                    
                    for (let i = 0; i < runs; i++) {
                        const startTime = performance.now();
                        const result = await vm.run();
                        const endTime = performance.now();
                        
                        results.push({
                            ...result,
                            executionTime: endTime - startTime
                        });
                        
                        // Only show progress for selected runs to avoid overwhelming output
                        if (i === 0 || i === 99 || i === 499 || i === 999 || (i + 1) % 100 === 0) {
                            addOutput(`Optimized Run ${i + 1}: ${result.results ? result.results.join(', ') : 'No result'} (${((endTime - startTime) * 1000).toFixed(1)}Œºs)`);
                        }
                    }
                    
                    const totalTime = results.reduce((sum, r) => sum + r.executionTime, 0);
                    const avgTime = totalTime / runs;
                    const lastResult = results[results.length - 1];
                    const vmStats = vm.getJITStatistics();
                    
                    addOutput(`
                        <strong>üèÅ Optimized Execution Results:</strong><br>
                        ‚Ä¢ Total Runs: ${runs} (all using JIT-compiled methods)<br>
                        ‚Ä¢ Average Time: ${(avgTime * 1000).toFixed(1)}Œºs<br>
                        ‚Ä¢ JIT Compilations: ${lastResult.jitCompilations || 0}<br>
                        ‚Ä¢ Optimized Methods: ${vmStats.optimizedMethods || 0}<br>
                        ‚Ä¢ Cached Methods: ${vmStats.cachedMethods || 0}<br>
                        ‚Ä¢ Performance: ${avgTime < 0.001 ? 'üöÄ Excellent' : avgTime < 0.005 ? '‚úÖ Good' : '‚ö†Ô∏è Slow'}<br>
                        ${vmStats.optimizedMethods > 0 ? `‚Ä¢ üß† <strong>Semantic Analysis:</strong> Using ${document.getElementById('llmToggle').checked ? 'AI-powered' : 'pattern-based'} optimized WAT generation` : ''}
                    `, 'result');
                    
                    updateStats({
                        executionTime: avgTime,
                        jitCompilations: lastResult.jitCompilations || 0,
                        optimizedMethods: vmStats.optimizedMethods || 0,
                        cachedMethods: vmStats.cachedMethods || 0,
                        jitEnabled: jitEnabled
                    });
                    
                } else {
                    // First time - run compilation demo
                    addOutput('<strong>üîÑ Running tests to trigger JIT compilation...</strong>');
                    
                    // Warmup phase to eliminate cold start effects
                    addOutput('<strong>üî• Warming up (eliminating cold start effects)...</strong>');
                    for (let w = 0; w < 10; w++) {
                        await vm.run();
                    }
                    addOutput('<strong>‚úÖ Warmup complete, starting measurements...</strong>');
                    
                    const runs = 1000; // Batch of 1000 runs for reliable averages
                    const results = [];
                    
                    for (let i = 0; i < runs; i++) {
                        const startTime = performance.now();
                        const result = await vm.run();
                        const endTime = performance.now();
                        
                        results.push({
                            ...result,
                            executionTime: endTime - startTime
                        });
                        
                        // Show key milestones and periodic progress (reduced frequency)
                        if (i === 0 || i === 4 || i === 99 || i === 499 || i === 999) {
                            addOutput(`Run ${i + 1}: ${result.results ? result.results.join(', ') : 'No result'} (${((endTime - startTime) * 1000).toFixed(1)}Œºs)`);
                        }
                        
                        // Show JIT compilation trigger
                        if (i === 999) { // JIT threshold is 1000, so this should trigger compilation
                            addOutput('<strong>üî• JIT compilation threshold reached! Starting async compilation...</strong>', 'result');
                        }
                        
                        // Progress indicator for long batch (reduced frequency)
                        if ((i + 1) % 500 === 0) {
                            addOutput(`<strong>üìä Progress: ${i + 1}/1000 runs completed...</strong>`);
                        }
                    }
                    
                    const totalTime = results.reduce((sum, r) => sum + r.executionTime, 0);
                    const avgTime = totalTime / runs;
                    const lastResult = results[results.length - 1];
                    const vmStats = vm.getJITStatistics();
                    
                    addOutput(`
                        <strong>üèÅ JIT Compilation Demo Results:</strong><br>
                        ‚Ä¢ Total Runs: ${runs} (all interpreted - compilation triggered)<br>
                        ‚Ä¢ Average Time: ${(avgTime * 1000).toFixed(1)}Œºs<br>
                        ‚Ä¢ JIT Compilations: ${lastResult.jitCompilations || 0}<br>
                        ‚Ä¢ Optimized Methods: ${vmStats.optimizedMethods || 0}<br>
                        ‚Ä¢ Cache Hit Rate: ${vmStats.cacheHitRate || 0}%<br>
                        ‚Ä¢ Status: Method compilation started (click again to use compiled version)<br>
                        ${vmStats.optimizedMethods > 0 ? `‚Ä¢ üß† <strong>Semantic Analysis:</strong> Methods analyzed and optimized using ${document.getElementById('llmToggle').checked ? 'AI-powered cloud' : 'local pattern'} analysis` : ''}
                    `, 'result');
                    
                    updateStats({
                        executionTime: avgTime * 1000, // Convert to microseconds
                        jitCompilations: lastResult.jitCompilations || 0,
                        optimizedMethods: vmStats.optimizedMethods || 0,
                        cachedMethods: vmStats.cachedMethods || 0,
                        jitEnabled: jitEnabled
                    });
                }
                
            } catch (error) {
                addOutput(`<strong>‚ùå Error:</strong> ${error.message}`, 'error');
            }
        });

        // Intensive computation test - Create a more complex workload
        document.getElementById('runIntensive').addEventListener('click', async () => {
            try {
                await initVM();
                
                vm.setJITEnabled(jitEnabled);
                vm.setDebugMode(debugMode);
                
                addOutput('<strong>üî• Running intensive computation benchmark...</strong>');
                addOutput('<strong>üìä Test: Computing nested factorial + triple polynomial + matrix-like operations (target: ~100Œºs)</strong>');
                
                // Create a much more intensive computation targeting 100Œºs baseline
                const intensiveBytecodes = [
                    // Part 1: Extended factorial-like computation (12! operations)
                    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, // Push 0-11
                    0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8,        // 11 multiplies
                    
                    // Part 2: Double Fibonacci-like computation
                    0x20, 0x21, 0xB0, 0x22, 0xB0, 0x23, 0xB0, 0x24, 0xB0, 0x25, 0xB0,        // First sequence
                    0x26, 0xB0, 0x27, 0xB0, 0x28, 0xB0, 0x29, 0xB0, 0x2A, 0xB0,              // Extended sequence
                    
                    // Part 3: Triple polynomial evaluation: (ax^4 + bx^3 + cx^2 + dx + e) * 3 iterations
                    // First polynomial: x^4 term
                    0x70, 0x70, 0x70, 0x70, 0xB8, 0xB8, 0xB8, 0x25, 0xB8,                    // receiver^4 * 5
                    // x^3 term  
                    0x70, 0x70, 0x70, 0xB8, 0xB8, 0x24, 0xB8, 0xB0,                          // receiver^3 * 4 + prev
                    // x^2 term
                    0x70, 0x70, 0xB8, 0x23, 0xB8, 0xB0,                                      // receiver^2 * 3 + prev
                    // x term
                    0x70, 0x22, 0xB8, 0xB0,                                                  // receiver * 2 + prev
                    // constant
                    0x21, 0xB0,                                                              // + 1
                    
                    // Part 4: Second polynomial iteration (different coefficients)
                    0x70, 0x70, 0x70, 0x70, 0xB8, 0xB8, 0xB8, 0x23, 0xB8,                    // receiver^4 * 3
                    0x70, 0x70, 0x70, 0xB8, 0xB8, 0x26, 0xB8, 0xB0,                          // receiver^3 * 6 + prev
                    0x70, 0x70, 0xB8, 0x21, 0xB8, 0xB0,                                      // receiver^2 * 1 + prev
                    0x70, 0x27, 0xB8, 0xB0,                                                  // receiver * 7 + prev
                    0x24, 0xB0,                                                              // + 4
                    
                    // Part 5: Third polynomial iteration (matrix-like operations)
                    0x70, 0x70, 0x70, 0x70, 0xB8, 0xB8, 0xB8, 0x22, 0xB8,                    // receiver^4 * 2
                    0x70, 0x70, 0x70, 0xB8, 0xB8, 0x28, 0xB8, 0xB0,                          // receiver^3 * 8 + prev
                    0x70, 0x70, 0xB8, 0x25, 0xB8, 0xB0,                                      // receiver^2 * 5 + prev
                    0x70, 0x23, 0xB8, 0xB0,                                                  // receiver * 3 + prev
                    0x26, 0xB0,                                                              // + 6
                    
                    // Part 6: Final accumulation with cross products
                    0x70, 0x70, 0xB8, 0xB0,                                                  // receiver^2 + all previous
                    0x70, 0x29, 0xB8, 0xB0,                                                  // receiver * 9 + all
                    0x2A, 0xB0,                                                              // + 10
                    
                    0x7C  // Return final result
                ];
                
                // Test interpreted execution first
                addOutput('<strong>üê¢ Phase 1: Interpreted execution (baseline)...</strong>');
                const interpretedTimes = [];
                
                for (let i = 0; i < 100; i++) {
                    const startTime = performance.now();
                    await vm.run();
                    const endTime = performance.now();
                    interpretedTimes.push(endTime - startTime);
                }
                
                const interpretedAvg = interpretedTimes.reduce((a, b) => a + b, 0) / interpretedTimes.length;
                addOutput(`<strong>üìä Interpreted Average:</strong> ${(interpretedAvg * 1000).toFixed(2)}Œºs`);
                
                // Now force JIT compilation by running 1000+ times
                addOutput('<strong>üî• Phase 2: Triggering JIT compilation...</strong>');
                
                for (let i = 0; i < 1000; i++) {
                    await vm.run();
                    if (i % 500 === 0) {
                        addOutput(`<strong>üìä Progress:</strong> ${i}/1000 runs completed...`);
                    }
                }
                
                const stats = vm.getJITStatistics();
                if (stats.jitCompilations > 0) {
                    addOutput('<strong>‚ö° JIT compilation triggered! Testing optimized performance...</strong>');
                    
                    // Test optimized execution
                    const optimizedTimes = [];
                    for (let i = 0; i < 100; i++) {
                        const startTime = performance.now();
                        await vm.run();
                        const endTime = performance.now();
                        optimizedTimes.push(endTime - startTime);
                    }
                    
                    const optimizedAvg = optimizedTimes.reduce((a, b) => a + b, 0) / optimizedTimes.length;
                    const speedup = interpretedAvg / optimizedAvg;
                    
                    addOutput(`<strong>üìä Optimized Average:</strong> ${(optimizedAvg * 1000).toFixed(2)}Œºs`);
                    addOutput(`<strong>üöÄ Speedup:</strong> ${speedup.toFixed(2)}x faster${speedup > 2 ? ' üî•' : speedup > 1.5 ? ' ‚ö°' : ' üìà'}`);
                    
                    // Performance classification
                    let perfClass = 'Excellent';
                    if (speedup < 1.2) perfClass = 'Minimal';
                    else if (speedup < 1.5) perfClass = 'Good';
                    else if (speedup < 2.0) perfClass = 'Very Good';
                    
                    addOutput(`<strong>üèÜ Performance Classification:</strong> ${perfClass}`);
                    
                } else {
                    addOutput('<strong>‚ö†Ô∏è JIT compilation not triggered - may need LLM optimization enabled</strong>');
                }
                
                // Update final statistics with properly scoped variables
                const finalAvg = stats.jitCompilations > 0 && typeof optimizedAvg !== 'undefined' ? optimizedAvg : interpretedAvg;
                updateStats({
                    executionTime: finalAvg * 1000,
                    jitCompilations: stats.jitCompilations,
                    optimizedMethods: stats.optimizedMethods,
                    cachedMethods: stats.cachedMethods,
                    jitEnabled: jitEnabled
                });
                
            } catch (error) {
                addOutput(`<strong>‚ùå Intensive computation error:</strong> ${error.message}`, 'error');
            }
        });

        // Configuration toggles
        document.getElementById('jitToggle').addEventListener('change', (e) => {
            jitEnabled = e.target.checked;
            if (vm) {
                vm.setJITEnabled(jitEnabled);
            }
            updateStats({ ...stats, jitEnabled });
            addOutput(`<strong>‚öôÔ∏è JIT compilation ${jitEnabled ? 'enabled' : 'disabled'}</strong>`);
        });

        document.getElementById('debugToggle').addEventListener('change', (e) => {
            debugMode = e.target.checked;
            if (vm) {
                vm.setDebugMode(debugMode);
            }
            addOutput(`<strong>üêõ Debug mode ${debugMode ? 'enabled' : 'disabled'}</strong>`);
        });

        document.getElementById('llmToggle').addEventListener('change', (e) => {
            const llmEnabled = e.target.checked;
            if (vm) {
                if (llmEnabled) {
                    if (vm.llmConfig.apiKey) {
                        // Real LLM optimization with loaded API key
                        vm.llmConfig.enabled = true;
                        addOutput(`<strong>‚òÅÔ∏è LLM optimization enabled (${vm.llmConfig.provider?.toUpperCase() || 'OpenAI'} API)</strong>`);
                        addOutput(`<strong>ü§ñ Ready to generate optimized WAT using real AI analysis</strong>`);
                        addOutput(`<strong>üéØ Strategy: LLM-optimized methods only (no traditional compilation)</strong>`);
                    } else {
                        // Fallback to mock mode if no API key
                        vm.llmConfig.enabled = true;
                        vm.llmConfig.apiKey = 'mock-key';
                        addOutput(`<strong>‚òÅÔ∏è LLM optimization enabled (mock mode - no keys file found)</strong>`);
                        addOutput(`<strong>ü§ñ Using fallback mock optimization for testing</strong>`);
                        addOutput(`<strong>üí° Create a 'keys' file with your OpenAI or Anthropic API key for real optimization</strong>`);
                    }
                } else {
                    vm.disableLLMOptimization();
                    addOutput(`<strong>‚òÅÔ∏è LLM optimization disabled</strong>`);
                    addOutput(`<strong>üîÑ All methods will continue being interpreted</strong>`);
                }
            }
        });

        document.getElementById('clearCache').addEventListener('click', () => {
            if (vm) {
                vm.clearMethodCache();
                updateStats({ ...stats, cachedMethods: 0 });
                addOutput('<strong>üóëÔ∏è Method cache cleared</strong>');
            }
        });

        document.getElementById('resetStats').addEventListener('click', () => {
            if (vm) {
                vm.resetStatistics();
                updateStats({
                    executionTime: 0, // Already in microseconds
                    jitCompilations: 0,
                    optimizedMethods: 0,
                    cachedMethods: 0,
                    jitEnabled: jitEnabled
                });
                addOutput('<strong>üìä Statistics reset</strong>');
            }
        });

        document.getElementById('testFunctionTable').addEventListener('click', () => {
            initVM()
                .then(() => {
                    addOutput('<strong>üß™ Testing function table functionality...</strong>');
                    const success = vm.testFunctionTable();
                    if (success) {
                        addOutput('<strong>‚úÖ Function table test passed!</strong>', 'result');
                    } else {
                        addOutput('<strong>‚ùå Function table test failed!</strong>', 'error');
                    }
                })
                .catch(error => {
                    addOutput(`<strong>‚ùå Function table test error:</strong> ${error.message}`, 'error');
                });
        });

        document.getElementById('detectTimer').addEventListener('click', () => {
            initVM()
                .then(() => {
                    detectTimerResolution();
                })
                .catch(error => {
                    addOutput(`<strong>‚ùå Timer detection error:</strong> ${error.message}`, 'error');
                });
        });

        document.getElementById('testWabt').addEventListener('click', () => {
            initVM()
                .then(() => {
                    testWabtLoading();
                })
                .catch(error => {
                    addOutput(`<strong>‚ùå wabt.js test error:</strong> ${error.message}`, 'error');
                });
        });

        document.getElementById('testWasmDump').addEventListener('click', () => {
            initVM()
                .then(() => {
                    testWasmDump();
                })
                .catch(error => {
                    addOutput(`<strong>‚ùå WASM dump test error:</strong> ${error.message}`, 'error');
                });
        });

        // Listen for result events from WASM
        window.addEventListener('squeakResult', (event) => {
            addOutput(`<strong>üéØ WASM Result Event:</strong> ${event.detail.value}`, 'result');
        });

        // Timer resolution detection and enhancement
        function detectTimerResolution() {
            const samples = [];
            const startTime = performance.now();
            
            // Collect timing samples
            for (let i = 0; i < 100; i++) {
                samples.push(performance.now());
            }
            
            // Find minimum non-zero difference
            let minDiff = Infinity;
            for (let i = 1; i < samples.length; i++) {
                const diff = samples[i] - samples[i-1];
                if (diff > 0 && diff < minDiff) {
                    minDiff = diff;
                }
            }
            
            const isIsolated = typeof crossOriginIsolated !== 'undefined' && crossOriginIsolated;
            const expectedResolution = isIsolated ? 0.005 : 0.1; // 5Œºs vs 100Œºs
            
            addOutput(`<strong>‚è±Ô∏è Timer Resolution Analysis:</strong><br>
                ‚Ä¢ Cross-Origin Isolated: ${isIsolated ? '‚úÖ YES (5Œºs)' : '‚ùå NO (100Œºs)'}<br>
                ‚Ä¢ Detected Resolution: ~${isFinite(minDiff) ? (minDiff * 1000).toFixed(1) : 'Infinity'}Œºs<br>
                ‚Ä¢ Expected Resolution: ~${(expectedResolution * 1000).toFixed(0)}Œºs<br>
                ‚Ä¢ Status: ${minDiff <= expectedResolution * 2 ? 'üéØ Optimal' : '‚ö†Ô∏è Limited'}`);
            
            // Check response headers
            checkCrossOriginHeaders();
        }

        // Test wabt.js loading functionality
        async function testWabtLoading() {
            addOutput('<strong>üîß Testing wabt.js loading...</strong>');
            
            if (!vm) {
                addOutput('<strong>‚ùå VM not initialized</strong>', 'error');
                return;
            }
            
            try {
                // Force wabt.js loading
                addOutput('üîÑ Attempting to load wabt.js from CDNs...');
                await vm.loadWabt();
                
                if (window.wabt && typeof window.wabt.readWasm === 'function') {
                    addOutput('<strong>‚úÖ wabt.js loaded successfully!</strong>', 'result');
                    addOutput(`üîç Available functions: ${Object.keys(window.wabt).join(', ')}`);
                    
                    // Test wabt.js functionality with a simple WAT
                    try {
                        const testWat = `(module
  (func $test (result i32)
    i32.const 42)
  (export "test" (func $test)))`;
                        
                        addOutput('üß™ Testing WAT parsing...');
                        const wasmModule = window.wabt.parseWat('test.wat', testWat);
                        
                        addOutput('üîç Testing WASM generation...');
                        const result = wasmModule.toBinary();
                        
                        addOutput(`‚úÖ WAT parsing test passed! Generated ${result.buffer.length} bytes of WASM`, 'result');
                        
                        // Test binary analysis
                        addOutput('üîç Testing binary analysis...');
                        const wasmModuleFromBinary = window.wabt.readWasm(result.buffer, { readDebugNames: true });
                        const watText = wasmModuleFromBinary.toText({ foldExprs: false, inlineExport: false });
                        
                        addOutput(`‚úÖ Binary analysis test passed! Generated ${watText.length} characters of WAT text`, 'result');
                        
                        // Cleanup
                        wasmModule.destroy();
                        wasmModuleFromBinary.destroy();
                        
                        addOutput('<strong>üéâ All wabt.js tests passed!</strong>', 'result');
                        
                    } catch (testError) {
                        addOutput(`<strong>‚ùå wabt.js functionality test failed:</strong> ${testError.message}`, 'error');
                    }
                    
                } else {
                    addOutput('<strong>‚ùå wabt.js loaded but missing expected functions</strong>', 'error');
                    if (window.wabt) {
                        addOutput(`Available: ${typeof window.wabt === 'object' ? Object.keys(window.wabt).join(', ') : typeof window.wabt}`);
                    }
                }
                
            } catch (error) {
                addOutput(`<strong>‚ùå wabt.js loading failed:</strong> ${error.message}`, 'error');
                addOutput('‚ÑπÔ∏è Falling back to basic WASM analysis for LLM optimization');
            }
        }

        // Test enhanced WASM dump functionality
        async function testWasmDump() {
            addOutput('<strong>üîç Testing Enhanced WASM Dump functionality...</strong>');
            
            if (!vm) {
                addOutput('<strong>‚ùå VM not initialized</strong>', 'error');
                return;
            }
            
            try {
                // Create a simple test WAT to demonstrate dump functionality
                const testWat = `(module
  (import "env" "getContextReceiver" (func $getContextReceiver (result i32)))
  (import "env" "extractIntegerValue" (func $extractIntegerValue (param i32) (result i32)))
  (import "env" "createSmallInteger" (func $createSmallInteger (param i32) (result i32)))
  (import "env" "pushOnStack" (func $pushOnStack (param i32 i32) (result i32)))
  
  (func $square (param $ctx i32) (result i32)
    (local $receiver_value i32)
    (local $result i32)
    
    ;; Get receiver and extract its value
    (local.set $receiver_value
      (call $extractIntegerValue (call $getContextReceiver (local.get $ctx))))
    
    ;; Square the value
    (local.set $result (i32.mul (local.get $receiver_value) (local.get $receiver_value)))
    
    ;; Push result and return success
    (call $pushOnStack (local.get $ctx)
      (call $createSmallInteger (local.get $result)))
    (i32.const 1)
  )
  (export "square" (func $square))
)`;
                
                addOutput('üîß Compiling test WAT module...');
                
                // Load required tools
                if (!window.wasmTools) {
                    await vm.loadWasmTools();
                }
                
                // Parse WAT to binary
                const wasmBytes = window.wasmTools.parseWat(testWat);
                addOutput(`‚úÖ WAT compiled successfully! Generated ${wasmBytes.length} bytes of WASM`);
                
                // Test the enhanced dump functionality
                addOutput('üîç Generating enhanced WASM dump...');
                const dumpResult = await vm.generateWASMDump(wasmBytes, testWat);
                
                // Display the dump in a formatted way
                const dumpLines = dumpResult.split('\n');
                let truncatedDump = '';
                let lineCount = 0;
                
                for (const line of dumpLines) {
                    if (lineCount < 50) { // Show first 50 lines
                        truncatedDump += line + '\n';
                        lineCount++;
                    } else {
                        truncatedDump += `... (${dumpLines.length - lineCount} more lines)\n`;
                        break;
                    }
                }
                
                addOutput(`<strong>üìÑ Enhanced WASM Dump (first 50 lines):</strong><br><pre style="font-size: 12px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; overflow-x: auto;">${truncatedDump}</pre>`);
                
                // Test individual components
                addOutput('<strong>üß™ Testing individual dump components...</strong>');
                
                // Test hex dump
                const hexDump = vm.generateHexDump(wasmBytes);
                const hexLines = hexDump.split('\n');
                addOutput(`‚úÖ Hex dump generated: ${hexLines.length} lines, ${hexDump.length} characters`);
                
                // Test section analysis
                const sectionAnalysis = vm.analyzeSections(wasmBytes);
                const sectionLines = sectionAnalysis.split('\n');
                addOutput(`‚úÖ Section analysis: ${sectionLines.length} lines, found ${sectionLines.filter(l => l.includes('Section')).length} sections`);
                
                // Test instruction analysis
                const codeAnalysis = vm.analyzeCodeSection(wasmBytes);
                const codeLines = codeAnalysis.split('\n');
                const instructionCount = codeLines.filter(l => l.includes('0x')).length;
                addOutput(`‚úÖ Code analysis: ${codeLines.length} lines, found ${instructionCount} instructions`);
                
                // Show a sample of instruction analysis
                const instructionSample = codeLines.filter(l => l.includes('0x')).slice(0, 5);
                if (instructionSample.length > 0) {
                    addOutput(`<strong>üìã Sample Instructions:</strong><br><pre style="font-size: 12px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;">${instructionSample.join('\n')}</pre>`);
                }
                
                // Test with wabt.js if available
                if (window.wabt && typeof window.wabt.readWasm === 'function') {
                    addOutput('üîß Testing wabt.js integration...');
                    const wasmModule = window.wabt.readWasm(wasmBytes, { readDebugNames: true });
                    const watText = wasmModule.toText({ foldExprs: false, inlineExport: false });
                    addOutput(`‚úÖ wabt.js integration working: Generated ${watText.length} characters of WAT text`);
                    wasmModule.destroy();
                } else {
                    addOutput('‚ö†Ô∏è wabt.js not available - using fallback analysis');
                }
                
                addOutput('<strong>üéâ Enhanced WASM Dump test completed successfully!</strong>', 'result');
                addOutput('<strong>üìã Features tested:</strong> Hex dump, Section analysis, Instruction parsing, wabt.js integration');
                
            } catch (error) {
                addOutput(`<strong>‚ùå WASM Dump test failed:</strong> ${error.message}`, 'error');
                console.error('WASM Dump test error:', error);
            }
        }

        // Debug function to check if COOP/COEP headers are working
        function checkCrossOriginHeaders() {
            fetch(window.location.href, { method: 'HEAD' })
                .then(response => {
                    const coop = response.headers.get('Cross-Origin-Opener-Policy');
                    const coep = response.headers.get('Cross-Origin-Embedder-Policy');
                    
                    addOutput(`<strong>üîç Header Check:</strong><br>
                        ‚Ä¢ COOP: ${coop || '‚ùå Missing'}<br>
                        ‚Ä¢ COEP: ${coep || '‚ùå Missing'}<br>
                        ‚Ä¢ Headers Working: ${(coop && coep) ? '‚úÖ YES' : '‚ùå NO'}`);
                    
                    if (!coop || !coep) {
                        addOutput(`<strong>üí° Solution:</strong> Headers not working. Try the alternative methods below.`, 'error');
                    }
                })
                .catch(error => {
                    addOutput(`<strong>‚ùå Header check failed:</strong> ${error.message}`, 'error');
                });
        }

        // Enhanced timing with multiple precision levels
        function precisionTimer() {
            const methods = {
                'performance.now': () => performance.now(),
                'Date.now': () => Date.now(),
            };
            

            
            return {
                start: Object.fromEntries(Object.entries(methods).map(([name, fn]) => [name, fn()])),
                end: function(startTimes) {
                    const endTimes = Object.fromEntries(Object.entries(methods).map(([name, fn]) => [name, fn()]));
                    return Object.fromEntries(Object.entries(startTimes).map(([name, start]) => 
                        [name, endTimes[name] - start]
                    ));
                }
            };
        }

        // Enhanced run function with multiple timer comparison
        async function enhancedRun() {
            const timer = precisionTimer();
            const startTimes = timer.start;
            
            const result = await vm.run();
            
            const durations = timer.end(startTimes);
            
            // Show comparison of different timing methods
            const timingReport = Object.entries(durations)
                .map(([method, duration]) => `${method}: ${(duration * 1000).toFixed(2)}Œºs`)
                .join('<br>‚Ä¢ ');
                
            addOutput(`<strong>üî¨ Multi-Timer Analysis:</strong><br>‚Ä¢ ${timingReport}`);
            
            return result;
        }

        // Auto-initialize VM on page load to enable LLM optimization if API keys exist
        document.addEventListener('DOMContentLoaded', () => {
            initVM()
                .then(() => {
                    addOutput('<strong>üéØ Phase 3 JIT Compilation Test Interface loaded!</strong>');
                    addOutput('<strong>üí° Tip:</strong> Use "Trigger JIT Compilation" to see the method get compiled after 1000 invocations. Click again to see optimized execution using cached compiled methods.');
                    addOutput('<strong>‚òÅÔ∏è NEW:</strong> Enable "LLM Optimization" for AI-powered JIT compilation. When disabled, methods stay interpreted (no traditional compilation)!');
                    addOutput('<strong>‚è±Ô∏è Timer Resolution:</strong> Click "Detect Timer Resolution" to check your browser\'s timing precision. For best results, serve this page with cross-origin isolation headers.');
                })
                .catch(error => {
                    addOutput(`<strong>‚ùå Auto-initialization failed:</strong> ${error.message}`, 'error');
                });
        });

        function toggleLLMOptimization() {
            if (window.squeakVM) {
                if (llmEnabled) {
                    window.squeakVM.disableLLMForDebugging();
                    document.querySelector('button[onclick="toggleLLMOptimization()"]').textContent = 'Enable LLM Optimization';
                } else {
                    window.squeakVM.enableLLMAfterDebugging();
                    document.querySelector('button[onclick="toggleLLMOptimization()"]').textContent = 'Disable LLM Optimization';
                }
                llmEnabled = !llmEnabled;
                console.log(`üîÑ LLM optimization ${llmEnabled ? 'enabled' : 'disabled'}`);
            }
        }
        
        function testOptimizationCorrectness() {
            if (window.squeakVM) {
                console.log('üß™ Testing optimization correctness...');
                console.log('‚ö†Ô∏è  This will run the same method twice - once interpreted, once optimized');
                console.log('üìä Check console for result comparison');
                
                // Display current validation statistics
                const stats = window.squeakVM.getJITStatistics();
                console.log('üìà Current Validation Statistics:');
                console.log(`   Validations passed: ${stats.validationsPassed}`);
                console.log(`   Validations failed: ${stats.validationsFailed}`);
                console.log(`   Success rate: ${stats.validationSuccessRate}%`);
                console.log(`   Retry attempts: ${stats.retryAttempts}`);
                console.log(`   Retry successes: ${stats.retrySuccesses}`);
                console.log(`   Retry success rate: ${stats.retrySuccessRate}%`);
                
                // This would need to be implemented to run specific test cases
                console.log('üîç Manual test: Run the method once with LLM disabled, then with LLM enabled');
                console.log('üìã Expected: Same result (1000000)');
                console.log('üêõ Actual: Different results indicate optimization bug');
            }
        }
    </script>
</body>
</html>
